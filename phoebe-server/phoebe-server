#!/usr/bin/python

"""
pip install flask
pip install flask-socketio
pip install gevent-websocket

to launch with MPI enabled:
PHOEBE_ENABLE_MPI=TRUE PHOEBE_MPI_NP=8 phoebe-server
"""

try:
    from flask import Flask, jsonify, request, redirect, Response, make_response, send_from_directory
    from flask_socketio import SocketIO, emit, join_room, leave_room
    from flask_cors import CORS
except ImportError:
    raise ImportError("dependencies not met: pip install flask flask-cors flask-socketio gevent-websocket")

### NOTE: tested to work with eventlet, not sure about gevent


################################ SERVER/APP SETUP ##############################


app = Flask(__name__)
CORS(app)
app._bundles = {}
app._clients = []
app._clients_per_bundle = {}
app._last_access_per_bundle = {}
app._verbose = True
app._killable = False

# we'll disable sorting the responses by keys so that we can control the sorting
# by qualifier instead of uniqueid.  This will sacrifice caching ability in the
# browser unless we set the order of all keys to be consistent.
app.config['JSON_SORT_KEYS'] = False

# Create the Flask-SQLAlchemy object and an SQLite database
# app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///phoebe.db'
# db = flask.ext.sqlalchemy.SQLAlchemy(app)

# Configure socket.io
app.config['SECRET_KEY'] = 'phoebesecret'
socketio = SocketIO(app)

def _uniqueid(N=16):
    """
    :parameter int N: number of character in the uniqueid
    :return: the uniqueid
    :rtype: str
    """
    return ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase) for _ in range(N))

def _new_bundleid(uniqueid=None, N=6):
    """
    will have 52**N uniqueids available.  But we'll check for duplicates just to
    make sure.
    """
    if uniqueid is None:
        uniqueid = _uniqueid(N=N)

    if uniqueid not in app._bundles.keys():
        return uniqueid
    else:
        # you should really enter the lottery, unless N is <= 3
        return _new_bundleid(uniqueid=None, N=N)

################################## ADDITIONAL IMPORTS ##########################

import phoebe
import numpy as np
import matplotlib.pyplot as plt
import json
import random
import string
import os
import sys
import tempfile
import traceback
import urllib2
import StringIO
import inspect
from time import sleep
from collections import OrderedDict
from datetime import datetime


phoebe.interactive_off()
phoebe.parameters._is_server = True


def bundle_memory_cleanup(stale_limit_seconds=600):
    # TODO: its possible to get an entry in _clients_per_bundle that isn't
    # available here.  The error message is raised in the UI and redirects
    # out... but the entry is still made here and never cleared

    now = datetime.now()
    for bundleid, last_access in app._last_access_per_bundle.items():
        stale_for = (now-last_access).total_seconds()
        clients = app._clients_per_bundle.get(bundleid, [])
        active_clients = [c for c in clients if c in app._clients]
        print("bundle_memory_cleanup: {} stale for {}/{} seconds with {} active clients and {} total clients".format(bundleid, stale_for, stale_limit_seconds, len(active_clients), len(clients)))
        # we'll delete if any of the following
        # * no active clients and past the stale limit
        # * no clients at all and stale for 30 seconds (in the case of closing where the client sent a deregister signal)
        # * stale for more than an hour from the webclient
        if (len(active_clients)==0 and stale_for > stale_limit_seconds) or (len(clients)==0 and stale_for > 30) or (stale_for > 60*60 and np.all([c.split('-')[0]=='web' for c in _client_types_for_bundle(bundleid)])):
            if app._verbose:
                print("bundle_memory_cleanup: deleting {}".format(bundleid))
            if bundleid in app._bundles.keys():
                del app._bundles[bundleid]
            if bundleid in app._clients_per_bundle.keys():
                del app._clients_per_bundle[bundleid]
            if bundleid in app._last_access_per_bundle.keys():
                del app._last_access_per_bundle[bundleid]

def _get_phoebe_funcs(module):
    ignore = ['_empty_array', 'deepcopy', 'fnmatch',
              'download_passband', 'list_installed_passbands', 'list_online_passbands', 'list_passbands', 'parameter_from_json', 'parse_json',
              'send_if_client', 'update_if_client',
              '_add_component', '_add_dataset', '_label_units_lims', '_run_compute', '_component_allowed_for_feature']


    return [o[0] for o in inspect.getmembers(module) if inspect.isfunction(o[1]) and o[0] not in ignore]

_available_kinds = {'component': _get_phoebe_funcs(phoebe.parameters.component),
                    'feature': _get_phoebe_funcs(phoebe.parameters.feature),
                    'dataset': _get_phoebe_funcs(phoebe.parameters.dataset),
                    'figure': _get_phoebe_funcs(phoebe.parameters.figure),
                    'compute': _get_phoebe_funcs(phoebe.parameters.compute)}

# logger = phoebe.logger('INFO')
_dir_tmpimages = os.path.join(tempfile.gettempdir(), 'phoebe-server-tmpimages')

if not os.path.exists(_dir_tmpimages):
    os.makedirs(_dir_tmpimages)


# TODO: can we also process and emit logger signals (https://docs.python.org/2/library/logging.handlers.html#sockethandler)?  Or at the least we could call b.run_checks after each command manually and broadcast those messages

###############################################################################
# We need to tell clients that its ok to accept API information from an external
# server since this will almost always be running from a different URL/port
# than the client.
# The following code that accomplishes this is taken (borrowed) almost entirely
# from http://flask.pocoo.org/snippets/56/
from datetime import timedelta
from flask import make_response, request, current_app
from functools import update_wrapper


def crossdomain(origin=None, methods=None, headers=None,
                max_age=21600, attach_to_all=True,
                automatic_options=True):
    if methods is not None:
        methods = ', '.join(sorted(x.upper() for x in methods))
    if headers is not None and not isinstance(headers, basestring):
        headers = ', '.join(x.upper() for x in headers)
    if not isinstance(origin, basestring):
        origin = ', '.join(origin)
    if isinstance(max_age, timedelta):
        max_age = max_age.total_seconds()

    def get_methods():
        if methods is not None:
            return methods

        options_resp = current_app.make_default_options_response()
        return options_resp.headers['allow']

    def decorator(f):
        def wrapped_function(*args, **kwargs):
            if automatic_options and request.method == 'OPTIONS':
                resp = current_app.make_default_options_response()
            else:
                resp = make_response(f(*args, **kwargs))
            if not attach_to_all and request.method != 'OPTIONS':
                return resp

            h = resp.headers

            h['Access-Control-Allow-Origin'] = origin
            h['Access-Control-Allow-Methods'] = get_methods()
            h['Access-Control-Max-Age'] = str(max_age)
            if headers is not None:
                h['Access-Control-Allow-Headers'] = headers
            return resp

        f.provide_automatic_options = False
        return update_wrapper(wrapped_function, f)
    return decorator

############################# CLIENT MANAGEMENT ################################

def _client_types_for_bundle(bundleid):
    return [c.split('-')[0] for c in app._clients_per_bundle.get(bundleid, [])]


############################ BUNDLE MANIPULATION ###############################


def _get_bundle_json(bundleid, do_jsonify=True):
    b = app._bundles.get(bundleid)
    app._last_access_per_bundle[bundleid] = datetime.now()

    data = b.to_json(incl_uniqueid=True)

    if do_jsonify:
        return jsonify(data)
    else:
        return data

def _value_string(param):
    param_type = param.__class__.__name__

    if param_type in ['StringParameter', 'ChoiceParameter', 'HierarchyParameter']:
        return param.get_value()
    elif param_type in ['ConstraintParameter']:
        return "(Constraint)"
    elif param_type in ['JobParameter']:
        return param.get_status()
    elif param_type in ['UnitParameter']:
        return str(param.get_value().to_string())
    elif param_type in ['IntParameter', 'DictParameter', 'BoolParameter']:
        return str(param.get_value())
    elif param_type in ['FloatParameter']:
        return str(param.get_value())
    elif param_type in ['FloatArrayParameter']:
        if isinstance(param._value, phoebe.dependencies.nparray.nparray.ArrayWrapper):
            return param._value.__str__()
        else:
            arr = param.get_value()
            # unit = str(param.get_default_unit())
            if len(arr):
                return "[{} ... {} ({})]".format(arr[0], arr[-1], len(arr))
            else:
                return "[] (empty)"
    else:
        return '({})'.format(param_type)

def _choices(parameter):
    if hasattr(parameter, 'choices'):
        return parameter.choices
    elif parameter.__class__.__name__ == 'BoolParameter':
        return ['True', 'False']
    # elif parameter.__class__.__name__ == 'UnitParameter':
        # return _unit_choices(parameter.get_value())
    else:
        return None

def _unit_choices(unit):
    physical_type = unit.physical_type

    if physical_type == 'dimensionless':
        if unit.to_string() in ['', 'dimensionless']:
            pass
        else:
            physical_types = [un.physical_type for un in unit.bases]
            if all([pt=='time' for pt in physical_types]):
                # then we're time/time, eg. s / yr
                # NOTE: doing same units on numerator and denominator will force this to be dimensionless
                # and then we won't know that its time at all.
                return ['d / yr', 'h / d', 'h / yr', 'min / d', 'min / h', 'min / yr', 's / min', 's / h', 's / d', 's / yr']
            elif physical_types == ['power', 'length']:
                # then assume flux units
                return ['W / m2', 'W / km2', 'W / pc2', 'W / AU2', 'W / solRad2', 'solLum / m2', 'solLum / km2', 'solLum / pc2', 'solLum / AU2', 'solLum / solRad2']
            else:
                return [unit.to_string()]
    elif physical_type == 'time':
        return ['yr', 'd', 'h', 'min', 's']
    elif physical_type == 'mass':
        return ['solMass', 'jupiterMass', 'earthMass', 'kg', 'g']
    elif physical_type == 'length':
        return ['solRad', 'jupiterRad', 'earthRad', 'AU', 'pc', 'km', 'm', 'cm', 'mm', 'um', 'nm', 'angstrom']
    elif physical_type == 'area':
        return ['solRad2', 'jupiterRad2', 'earthRad2', 'AU2', 'pc2', 'km2', 'm2', 'cm2']
    elif physical_type == 'volume':
        return ['solRad3', 'jupiterRad3', 'earthRad3', 'AU3', 'pc3', 'km3', 'm3', 'cm3']
    elif physical_type == 'speed':
        return ['solRad / d', 'solRad / s', 'km / h', 'km / s', 'm / h', 'm / s']
    elif physical_type == 'angle':
        return ['rad', 'deg']
    elif physical_type == 'angular speed':
        return ['rad / yr', 'rad / d', 'rad / h', 'rad / s', 'deg / yr', 'deg / d', 'deg / h', 'deg / s']
    elif physical_type == 'temperature':
        # astropy cannot convert to u.deg_C or u.imperial.deg_F
        # could support with equivalencies: https://docs.astropy.org/en/stable/units/equivalencies.html#temperature-equivalency
        # but then we'd need to manually pass that within PHOEBE whenever
        # the physical type is temperature
        return ['K']
    elif physical_type == 'power':
        return ['W', 'solLum']
    else:
        return [unit.to_string()]

def _param_json_overview(param):
    p = {'uniqueid': param.uniqueid,
         'class': param.__class__.__name__,
         'valuestr': _value_string(param),
         'unitstr': param.default_unit.to_string() if hasattr(param, 'default_unit') else '',
         'readonly': param.context in ['model'] or param.qualifier in ['phoebe_version'] or (hasattr(param, 'is_constraint') and param.is_constraint is not None),
         }

    advanced_filter = []
    if not param.is_visible:
        advanced_filter.append('not_visible')
    if '_default' in [param.component, param.dataset]:
        advanced_filter.append('is_default')
    if param.advanced:
        advanced_filter.append('is_advanced')
    if hasattr(param, 'choices') and len(param.choices) <= 1:
        advanced_filter.append('is_single')
        p['readonly'] = True
    if param.context=='constraint':
        advanced_filter.append('is_constraint')

    p['advanced_filter'] = advanced_filter


    for k,v in param.meta.items():
        if k in ['time', 'history', 'fitting', 'feedback', 'plugin']:
            continue
        p[k] = v

    return p

def _param_json_detailed(param):
    p  = {'description': param.description}

    if param.__class__.__name__ == 'ConstraintParameter':
        p['related_to'] = {p.uniqueid: p.twig for p in param.vars.to_list()}
        p['constraint'] = {}
        p['constrains'] = {p.uniqueid: p.twig for p in [param.constrained_parameter]}
    else:
        p['related_to'] = {p.uniqueid: p.twig for p in param.related_to} if hasattr(param, 'related_to') else {}
        p['constraint'] = {p.uniqueid: p.twig for p in [param.is_constraint]} if hasattr(param, 'is_constraint') and param.is_constraint is not None else {}
        p['constrains'] = {p.uniqueid: p.twig for p in param.constrains} if hasattr(param, 'constrains') else {}

    if hasattr(param, 'limits'):
        if hasattr(param, 'default_unit'):
            p['limits'] = [l.to(param.default_unit).value if l is not None else None for l in param.limits] + [param.default_unit.to_string()]
        else:
            p['limits'] = param.limits + [None]
    # else:
        # p['limits'] = None

    if hasattr(param, 'choices') or param.__class__.__name__ in ['BoolParameter']:
        p['choices'] = _choices(param)

    if hasattr(param, 'default_unit'):
        p['unit_choices'] = _unit_choices(param.default_unit)
    # else:
        # p['unit_choices'] = None

    return p

def _sort_tags(group, tags):
    if group=='contexts':
        # try to order contexts in same order as shown in UI.. then fill in with the rest
        lst = [k for k in ['constraint', 'component', 'feature', 'dataset', 'figure', 'compute', 'model'] if k in tags]
        for k in tags:
            if k not in lst:
                lst.append(k)
        return lst
    else:
        return sorted(tags)


############################ HTTP ROUTES ######################################
def _get_response(data, status_code=200, api=False, **metawargs):
    d = {}
    d['data'] = data
    d['meta'] = metawargs
    if api:
        resp = jsonify(d)
        resp.status_code = status_code
        return resp
    else:
        return d

@app.route("/info", methods=['GET'])
@crossdomain(origin='*')
def info():
    if app._verbose:
        print("info", phoebe.__version__, app._parent)

    bundle_memory_cleanup()

    return _get_response({'success': True, 'phoebe_version': phoebe.__version__, 'parentid': app._parent,
                          'nclients': len(app._clients), 'clients': app._clients,
                          'nbundles': len(app._bundles.keys()), 'clients_per_bundle': app._clients_per_bundle, 'last_access_per_bundle': app._last_access_per_bundle,
                          'available_kinds': _available_kinds
                          },
                          api=True)

@app.route('/new_bundle/<string:type>', methods=['GET'])
@crossdomain(origin='*')
def new_bundle(type):
    """
    Initiate a new bundle object, store it to local memory, and return the bundleid.
    The client is then responsible for making an additional call to access parameters, etc.

    type: 'binary:detached'
    """
    if app._verbose:
        print("new_bundle(type={})".format(type))

    def _new_bundle(constructor, **kwargs):
        try:
            b = getattr(phoebe, constructor)(**kwargs)
        except Exception as err:
            return _get_response({'success': False, 'error': str(err)}, api=True)
        else:
            bundleid = _new_bundleid()
            app._bundles[bundleid] = b
            return _get_response({'success': True, 'bundleid': bundleid}, api=True)

    if type == 'single':
        return _new_bundle('default_star')
    elif type == 'binary:detached':
        return _new_bundle('default_binary')
    # elif type == 'binary:detached:primary':
        # return _new_bundle('default_binary', semidetached='primary')
    # elif type == 'binary:detached:secondary':
        # return _new_bundle('default_binary', semidetached='secondary')
    elif type == 'binary:contact':
        return _new_bundle('default_binary', contact_binary=True)
    # elif type == 'triple:12:detached':
    #     return _new_bundle('default_triple', inner_as_primary=False, inner_as_contact=False)
    # elif type == 'triple:12:contact':
    #     return _new_bundle('default_triple', inner_as_primary=False, inner_as_contact=True)
    # elif type == 'triple:21:detached':
    #     return _new_bundle('default_triple', inner_as_primary=True, inner_as_contact=False)
    # elif type == 'triple:21:contact':
    #     return _new_bundle('default_triple', inner_as_primary=True, inner_as_contact=True)
    else:
        return _get_response({'success': False, 'error': 'bundle with type "{}" not implemented'.format(type)}, api=True)

@app.route('/open_bundle', methods=['POST'])
@crossdomain(origin='*')
def open_bundle():
    """
    """
    if app._verbose:
        print("open_bundle")

    try:
        data = json.loads(request.data)
    except ValueError:
        data = {}

    if 'file' in request.files:
        if app._verbose: print("opening bundle from file")
        file = request.files['file']
        bundle_data = json.load(file)
    else:
        if app._verbose: print("opening bundle from json data")
        try:
            bundle_data = data['json']
        except:
            return _get_response({'success': False, 'error': "could not read json data"}, api=True)


    try:
        b = phoebe.Bundle(bundle_data)
    except Exception as err:
        return _get_response({'success': False, 'error': str(err)}, api=True)

    bundleid = data.get('bundleid', None)
    if app._verbose:
        print("trying bundleid={}".format(bundleid))
    bundleid = _new_bundleid(bundleid)
    app._bundles[bundleid] = b
    app._last_access_per_bundle[bundleid] = datetime.now()

    return _get_response({'success': True, 'bundleid': bundleid}, api=True)

@app.route('/json_bundle/<string:bundleid>', methods=['GET'])
@crossdomain(origin='*')
def json_bundle(bundleid):
    """
    """
    if app._verbose:
        print("json_bundle(bundleid={})".format(bundleid))

    if bundleid not in app._bundles.keys():
        print("json_bundle error: bundleid={}, app._bundles.keys()={}".format(bundleid, app._bundles.keys()))
        return _get_response({'success': False, 'error': 'bundle not found with bundleid=\'{}\''.format(bundleid)}, api=True)

    bjson = _get_bundle_json(bundleid, do_jsonify=False)

    return _get_response({'success': True, 'bundle': bjson, 'bundleid': bundleid}, bundleid=bundleid, api=True)

@app.route('/save_bundle/<string:bundleid>', methods=['GET'])
@crossdomain(origin='*')
def save_bundle(bundleid):
    """
    """
    if app._verbose:
        print("save_bundle(bundleid={})".format(bundleid))


    if bundleid not in app._bundles.keys():
        return _get_response({'success': False, 'error': 'bundle not found with bundleid={}'}, api=True)

    resp = _get_bundle_json(bundleid, do_jsonify=True)

    resp.headers.set('Content-Type', 'text/json')
    resp.headers.set('Content-Disposition', 'attachment', filename='{}.bundle'.format(bundleid))

    return resp

@app.route('/bundle/<string:bundleid>', methods=['GET'])
@crossdomain(origin='*')
def bundle(bundleid):
    """
    """
    if app._verbose:
        print("bundle(bundleid={})".format(bundleid))


    if bundleid not in app._bundles.keys():
        return _get_response({'success': False, 'error': 'bundle not found with bundleid={}'.format(bundleid)}, api=True)

    b = app._bundles.get(bundleid)
    app._last_access_per_bundle[bundleid] = datetime.now()

    param_list = sorted([_param_json_overview(param) for param in b.to_list()], key=lambda p: p['qualifier'])
    param_dict = OrderedDict((p.pop('uniqueid'), p) for p in param_list)

    tags = {k: _sort_tags(k, v) for k,v in b.tags.items()}

    return _get_response({'success': True, 'parameters': param_dict, 'tags': tags}, api=True)

@app.route('/parameter/<string:bundleid>/<string:uniqueid>', methods=['GET'])
@crossdomain(origin='*')
def parameter(bundleid, uniqueid):
    """
    """
    if app._verbose:
        print("parameter(bundleid={}, uniqueid={})".format(bundleid, uniqueid))

    if bundleid not in app._bundles.keys():
        return _get_response({'success': False, 'error': 'bundle not found with bundleid={}'.format(bundleid)}, api=True)

    b = app._bundles.get(bundleid)
    app._last_access_per_bundle[bundleid] = datetime.now()

    try:
        param = b.get_parameter(uniqueid=uniqueid, check_visible=False, check_advanced=False, check_default=False)
    except:
        return _get_response({'success': False, 'error': 'could not find parameter with uniqueid={}'.format(uniqueid)}, api=True)

    data = _param_json_detailed(param)

    return _get_response({'success': True, 'parameter': data}, api=True)


############################# WEBSOCKET ROUTES ################################

########## SOCKET ERRORS
@socketio.on_error()
def error_handler(err):
    print("websocket error:", err)

    if app._verbose:
        ex_type, ex, tb = sys.exc_info()
        print traceback.print_tb(tb)

    emit('msg', {'success': False, 'id': None, 'level': 'error', 'msg': 'websocket: '+err.message}, broadcast=False)



########## CLIENT MANAGEMENT
@socketio.on('connect')
def connect():
    if app._verbose:
        print('Client connected')

    # emit('connect', {'success': True, 'data': {'clients': app._clients, 'parentid': app._parent}})

@socketio.on('disconnect')
def disconnect():
    if app._verbose:
        print('Client disconnected')

    # emit('disconnect', {'success': True, 'data': {'clients': app._clients, 'parentid': app._parent}})


@socketio.on('register client')
def register_client(msg):
    clientid = msg.get('clientid', None)
    bundleid = msg.get('bundleid', None)
    if bundleid is not None and bundleid not in app._bundles.keys():
        err = 'bundle not found with bundleid={}'.format(bundleid)
        if app._verbose:
            print("register client {} error: {}".format(msg, err))

        emit('{}:errors:react'.format(bundleid), {'success': False, 'error': err}, broadcast=False)
        return

    if app._verbose:
        print("register_client(clientid={}, bundleid={})".format(clientid, bundleid))

    if clientid is not None and clientid not in app._clients:
        app._clients.append(clientid)

    if bundleid is not None:
        if bundleid not in app._clients_per_bundle.keys():
            app._clients_per_bundle[bundleid] = [clientid]
        elif clientid not in app._clients_per_bundle.get(bundleid, []):
            app._clients_per_bundle[bundleid].append(clientid)

    bundle_memory_cleanup()

@socketio.on('deregister client')
def deregister_client(msg):
    clientid = msg.get('clientid', None)
    bundleid = msg.get('bundleid', None)
    if app._verbose:
        print("deregister_client(clientid={}, bundleid={})".format(clientid, bundleid))

    if bundleid is not None:
        app._clients_per_bundle[bundleid] = [c for c in app._clients_per_bundle.get(bundleid, []) if c!=clientid]

    elif clientid is not None and clientid in app._clients:
        # note: we'll leave the clientid in app._clients_per_bundle.  Those bundles
        # will become stale and eventually deleted by timeout in bundle_memory_cleanup.
        app._clients.remove(clientid)

    # now cleanup from memory any bundle with NO cients
    bundle_memory_cleanup()

########## BUNDLE METHODS
@socketio.on('set_value')
def set_value(msg):
    if app._verbose:
        print("set_value: ", msg)

    bundleid = msg.pop('bundleid')

    if bundleid not in app._bundles.keys():
        err = 'bundle not found with bundleid={}'.format(bundleid)
        if app._verbose:
            print("set_value {} error: {}".format(msg, err))
        emit('{}:errors:react'.format(bundleid), {'success': False, 'error': err}, broadcast=False)
        return


    b = app._bundles[bundleid]
    app._last_access_per_bundle[bundleid] = datetime.now()

    msg.setdefault('check_visible', False)
    msg.setdefault('check_default', False)
    msg.setdefault('check_advanced', False)

    client_types = _client_types_for_bundle(bundleid)
    if 'web' in client_types or 'desktop' in client_types:
        is_visible_before = {p.uniqueid: p.is_visible for p in b.to_list(check_visible=False, check_default=False, check_advanced=False)}

    try:
        # TODO: handle getting nparray objects (probably as json strings/unicodes)
        b.set_value_all(**msg)
        ps_constraints = b.run_delayed_constraints()
    except Exception as err:
        if app._verbose:
            print("set_value {} error: {}".format(msg, err.message))
        emit('{}:errors:react'.format(bundleid), {'success': False, 'error': err.message}, broadcast=False)
        return

    try:
        ps_list = ps_constraints + b.filter(**{k:v for k,v in msg.items() if k not in ['value']}).to_list()
    except Exception as err:
        if app._verbose:
            print("set_value {} error on filter: {}".format(msg, err.message))
        emit('{}:errors:react'.format(bundleid), {'success': False, 'error': err.message}, broadcast=False)
        return
    else:
        if 'web' in client_types or 'desktop' in client_types:

            # we need to also include parameters in which the visibility has changed
            is_visible_changed = {p.uniqueid: p.is_visible for p in b.to_list(check_visible=False, check_default=False, check_advanced=False) if p.is_visible!=is_visible_before.get(p.uniqueid, None)}
            # TODO: need to figure out what should be shown in the client if a new items has become visible but not within the filter
            # TODO: tag visibility in the client needs to change based on the change in parameter visibilities

            ps_list += b.filter(uniqueid=is_visible_changed.keys(), check_visible=False, check_advanced=False, check_default=False).to_list()

            param_list = sorted([_param_json_overview(param) for param in ps_list], key=lambda p: p['qualifier'])
            param_dict = OrderedDict((p.pop('uniqueid'), p) for p in param_list)

            if app._verbose:
                print("set_value success, broadcasting changes:react: {}".format(param_dict))

            emit('{}:changes:react'.format(bundleid), {'success': True, 'parameters': param_dict}, broadcast=True)

        if 'python' in client_types:
            ps_dict = {p.uniqueid: {'value': p.get_value()} for p in ps_list}

            if app._verbose:
                print("set_value success, broadcasting changes:python: {}".format(ps_dict))

            emit('{}:changes:python'.format(bundleid), {'success': True, 'parameters': ps_dict}, broadcast=True)


# TODO: now that set_default_unit_all returns a PS, we could use bundle_method
# instead? - need to see what needs to be done from the python-client side
@socketio.on('set_default_unit')
def set_default_unit(msg):
    if app._verbose:
        print("set_default_unit: ", msg)

    bundleid = msg.pop('bundleid')

    if bundleid not in app._bundles.keys():
        err = 'bundle not found with bundleid={}'.format(bundleid)
        if app._verbose:
            print("set_default_unit {} error: {}".format(msg, err))
        emit('{}:errors:react'.format(bundleid), {'success': False, 'error': err}, broadcast=False)
        return


    b = app._bundles[bundleid]
    app._last_access_per_bundle[bundleid] = datetime.now()

    msg.setdefault('check_visible', False)
    msg.setdefault('check_default', False)
    msg.setdefault('check_advanced', False)

    client_types = _client_types_for_bundle(bundleid)

    try:
        # TODO: handle getting nparray objects (probably as json strings/unicodes)
        b.set_default_unit_all(**msg)
    except Exception as err:
        if app._verbose:
            print("set_default_unit {} error: {}".format(msg, err.message))
        emit('{}:errors:react'.format(bundleid), {'success': False, 'error': err.message}, broadcast=False)
        return

    try:
        ps_list = b.filter(**{k:v for k,v in msg.items() if k not in ['unit']}).to_list()
    except Exception as err:
        if app._verbose:
            print("set_default_unit {} error on filter: {}".format(msg, err.message))
        emit('{}:errors:react'.format(bundleid), {'success': False, 'error': err.message}, broadcast=False)
        return
    else:
        if 'web' in client_types or 'desktop' in client_types:
            param_list = sorted([_param_json_overview(param) for param in ps_list], key=lambda p: p['qualifier'])
            param_dict = OrderedDict((p.pop('uniqueid'), p) for p in param_list)

            if app._verbose:
                print("set_default_unit success, broadcasting changes:react: {}".format(param_dict))

            emit('{}:changes:react'.format(bundleid), {'success': True, 'parameters': param_dict}, broadcast=True)

        if 'python' in client_types:
            ps_dict = {p.uniqueid: {'default_unit': p.get_default_unit()} for p in ps_list}

            if app._verbose:
                print("set_default_unit success, broadcasting changes:python: {}".format(ps_dict))

            emit('{}:changes:python'.format(bundleid), {'success': True, 'parameters': ps_dict}, broadcast=True)

@socketio.on('bundle_method')
def bundle_method(msg):
    if app._verbose:
        print("bundle_method: ", msg)

    bundleid = msg.pop('bundleid', None)

    if bundleid is None:
        emit('errors' {'success': False, 'error': "must provide bundleid"}, broadcast=False)
        return

    if bundleid not in app._bundles.keys():
        err = 'bundle not found with bundleid={}'.format(bundleid)
        if app._verbose:
            print("bundle_method {} error: {}".format(msg, err))
        emit('{}:errors:react'.format(bundleid), {'success': False, 'error': err}, broadcast=False)
        return


    b = app._bundles[bundleid]
    app._last_access_per_bundle[bundleid] = datetime.now()

    # msg.setdefault('check_visible', False)
    # msg.setdefault('check_default', False)
    # msg.setdefault('check_advanced', False)

    client_types = _client_types_for_bundle(bundleid)

    method = msg.pop('method')

    try:
        ps = getattr(b, method)(**msg)
        ps_list = ps.to_list()
    except Exception as err:
        if app._verbose:
            print("bundle_method {} error: {}".format(msg, err.message))
        emit('{}:errors:react'.format(bundleid), {'success': False, 'error': err.message}, broadcast=False)
        return

    # TODO: handle any parameters in which the choices may have changed (columns, for example)

    if 'web' in client_types or 'desktop' in client_types:
        param_list = sorted([_param_json_overview(param) for param in ps_list], key=lambda p: p['qualifier'])
        param_dict = OrderedDict((p.pop('uniqueid'), p) for p in param_list)

        if app._verbose:
            print("bundle_method success, broadcasting changes:react: {}".format(param_dict))


        packet = {'success': True, 'parameters': param_dict}

        # if we added new parameters, then the tags likely have changed
        if method.split('_')[0] in ['add', 'remove', 'rename']:
            packet['tags'] = {k: _sort_tags(k, v) for k,v in b.tags.items()}

        if method.split('_')[0] == 'add':
            packet['add_filter'] = {method.split('_')[1]: getattr(ps, method.split('_')[1])}

        emit('{}:changes:react'.format(bundleid), packet, broadcast=True)

    if 'python' in client_types:
        ps_dict = {p.uniqueid: {'default_unit': p.get_default_unit()} for p in ps_list}

        if app._verbose:
            print("bundle_method success, broadcasting changes:python: {}".format(ps_dict))

        emit('{}:changes:python'.format(bundleid), {'success': True, 'parameters': ps_dict}, broadcast=True)





if __name__ == "__main__":
    #phoebe_server.py port, parent, host
    if len(sys.argv) >= 2:
        port = int(float(sys.argv[1]))
    else:
        port = 5555

    if len(sys.argv) >= 3:
        parent = sys.argv[2]
    else:
        parent = 'notprovided'

    if len(sys.argv) >=4:
        host = sys.argv[3]
    else:
        host = '127.0.0.1'

    app._parent = parent

    if app._verbose:
        print("*** SERVER READY at {}:{} ***".format(host, port))

    socketio.run(app, host=host, port=port)
